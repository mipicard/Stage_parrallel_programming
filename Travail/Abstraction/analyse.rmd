
Comparaison de l'exécution des algorithmes naïfs de multiplication de matrice sur CPU et GPU
===================================

Le but de cette expérience est de montrer les différences de performances entre la multiplication sur CPU et sur GPU de matrices, en utilisant les algorithmes naîfs de calculs. Ceci dans le but de débuter en programmation parrallèle et d'expérimenter techniques et utilisation du language CUDA.

Nous allons tester le temps d'exécution de 3 algorithmes : le 1er en CPU naïf, le 2eme en GPU naïf et le 3eme en GPU avec mémoire shader, le 4ème étant une modification du 3eme pour augmenter le nombre de calcul exécuté par thread à 4.

Nous nous attendons à des performances qui décroisse exponentiellement avec la taille de la matrice pour le 1er algorithme (CPU), et des performances à peu près stables pour les 2 algorithmes sur GPU, avec un léger gain de puissance pour le 3eme algorithme, ainsi qu'à une possible amélioration supplémentaire pour le dernier, avec un doute sur son efficacité dû aux transferts mémoires.

```{r parsing}
library(ggplot2)
library(plyr)
library(grid)
library(methods)
library(scales)
# csv file separated by ',' decimal signe is '.'
dataCPU<-data.frame(read.csv2(file="Resultat_CPU.csv",sep=',',dec='.'))
dataGPU12<-data.frame(read.csv2(file="Resultat_GPU12.csv",sep=',',dec='.'))
dataGPU3<-data.frame(read.csv2(file="Resultat_GPU3.csv",sep=',',dec='.'))
# How is organized data
str(dataCPU)
str(dataGPU12)
str(dataGPU3)
```

Results
-------

###   Execution time

```{r ExecTime, width=40}
# ddply => summarize the results, compute mean, sd and se
# mean is computed by grouping lines with same value for the columns given in
# argument
# see http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/
statCPU<-ddply(dataCPU,c("Algo", "TailleMat"),summarise,meanTC=mean(TempsCalc))
statGPU12<-ddply(dataGPU12,c("Algo", "TailleMat"),summarise,meanTC=mean(TempsCalc))
statGPU3<-ddply(dataGPU3,c("Algo", "TailleMat"),summarise,meanTC=mean(TempsCalc))
# Here we have two parameters monitor that appears on x
# and Log that is used for color and groupping
#log50_trans = function() trans_new("log50",function(x) log(x,50), function(x) 50^x)
p <- ggplot(statCPU,aes(x=TailleMat, y=meanTC, colour=Algo, shape=Algo))
q <- ggplot(statGPU12,aes(x=TailleMat, y=meanTC, colour=Algo, shape=Algo))
r <- ggplot(statGPU3,aes(x=TailleMat, y=meanTC, colour=Algo, shape=Algo))
p <- p + scale_x_continuous(trans=log2_trans())
q <- q + scale_x_continuous(trans=log2_trans())
r <- r + scale_x_continuous(trans=log2_trans())
#p <- p + coord_trans(y="log10")
# Plot as bar (histograms
#p <- p + geom_point(size=0.25)
p <- p + geom_line(size=0.5)
q <- q + geom_line(size=0.5)
r <- r + geom_line(size=0.5)
#p <- p + geom_smooth(size=0.25)
#q <- q + geom_smooth(size=0.25)
#p  <-  p + geom_bar(stat="identity", position="dodge")
#p <- p + facet_grid(. ~ Algo)
#p  <-  p + geom_errorbar(aes(ymin=mean-se, ymax=mean+se),position="dodge")
# Color gradiant:
#p <- p + scale_fill_gradient2(low="#FFFFCC", high="#F03B20",mid="#FEB24C",midpoint=0.5,name="Logging\ninterval (s)")
# Rename the axes
p <- p + xlab("Matrice width*width(log2)")
p <- p + ylab("Execution time (s)")
q <- q + xlab("Matrice width*width")
q <- q + ylab("Execution time (s)")
# Force y to start at 0
p <- p + expand_limits(x=10,y=0)
q <- q + expand_limits(x=10,y=0)
r <- r + expand_limits(x=10,y=0)
# Theme customisation, commented out, play with it at your wish
# p <- p + theme_bw()
# p <-  p + theme(panel.grid.minor = element_line(colour = "black", linetype="dashed", size = 0.1),
#         panel.grid.major = element_line(colour = "black", size = 0.1),
#         legend.position="bottom", legend.key.size = unit(.5, "cm"))
#p <- p+ theme(legend.position="none")
show(p)
show(q)
show(r)
# Save the plot as a pdf file
#ggsave(plot = p,file = "MultMatrice_param.pdf")

```

Is that what we expected ?

+ Yes: what can we conclude
+ No: Why, new hypothesis ?

Conclusions
-----------

What did we leaned from this experiment ?
Should we do something else ?
New experiments ?

```{r free, echo=F}
# Clean R environment
remove(p)
remove(q)
remove(r)
remove(statCPU)
remove(statGPU12)
remove(statGPU3)
remove(dataCPU)
remove(dataGPU12)
remove(dataGPU3)
```
